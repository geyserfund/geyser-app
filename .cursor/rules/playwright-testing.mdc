# Playwright E2E Testing Guidelines

## üìã Meta-Rule: Living Documentation

**This file evolves based on real project experience.**

- Update rules immediately when mistakes are identified
- Document what went wrong and how it was fixed
- Add patterns and anti-patterns as they emerge
- Keep rules practical and grounded in actual scenarios
- **Update rules BEFORE continuing with implementation**

---

## üéØ Step-by-Step Workflow for Writing Tests

Follow this workflow for EVERY test to ensure correctness and avoid wasted iterations.

### Step 1: Investigate Actual App Behavior

**NEVER write tests based on assumptions or old tests. ALWAYS verify what the app actually does.**

#### Required Investigation

Before writing ANY test code, answer these questions by reading the actual codebase:

1. **What component/context handles this feature?**
   - Find the relevant file (e.g., `src/context/auth.tsx`, `src/components/LoginButton.tsx`)
   
2. **What function executes the behavior?**
   - Read the actual implementation
   - Don't assume‚Äîverify!

3. **What network requests are made?**
   - REST endpoints? (e.g., `/logout`)
   - GraphQL queries? (e.g., `Me` query)
   - None? (local state only)

4. **What state changes occur?**
   - Local state updates? (e.g., `setUser(defaultUser)`)
   - Global atoms? (e.g., Jotai atoms)
   - Server state?

5. **How does the UI respond?**
   - Direct re-render?
   - Via `useEffect`?
   - What triggers the UI update?

#### Example: Investigating Logout

```typescript
// Found in src/context/auth.tsx:
const logout = useCallback(() => {
  setUser({ ...defaultUser })  // Sets user.id = 0
  setUserAccountKeyPair(undefined)
  setFollowedProjects([])
  fetch(`${authServiceEndPoint}/logout`, { credentials: 'include' })
  // ‚úÖ Calls /logout endpoint (REST)
  // ‚ùå Does NOT query GraphQL
}, [])

// UI updates via useEffect:
useEffect(() => {
  if (user.id === 0) {
    setIsLoggedIn(false)
  }
}, [user.id])
```

**Result**: Logout is local state clear + REST call to `/logout`. NO GraphQL query.

### Step 2: Verify UI Element Rendering

**Check how elements are actually rendered before writing selectors.**

#### Check Component Code

```typescript
// Example: ProfileNavContent.tsx
<MenuItem onClick={logout}>
  <Body size="md">{t('Sign Out')}</Body>
</MenuItem>

// ‚úÖ MenuItem has role="menuitem", not "button"!
// ‚úÖ Text is wrapped in t() for i18n
```

#### Check Conditional Rendering

```typescript
// Example: ConnectWithNostr.tsx
if (!window.nostr) return null  // ‚Üê Button won't render without window.nostr!

// ‚úÖ Must mock window.nostr BEFORE page.goto()
```

#### Check for Required Prerequisites

- Window objects: `window.nostr`, `window.webln`
- Authentication state: `isLoggedIn`, `user.id`
- Feature flags or environment variables

### Step 3: Identify What Needs Mocking

Based on your investigation:

**Mock These:**
- External/unstable services (browser extensions, payment processors)
- Window objects (e.g., `window.nostr`)
- Endpoints that are hard to test (external auth)

**Don't Mock These:**
- Your own API (let it run naturally when possible)
- Local state changes (let them happen)
- UI updates (verify them instead)

**Example:**
```typescript
// Login Flow Investigation Result:
// - Needs: window.nostr mock (browser extension)
// - Needs: /auth/nostr endpoint mock (external auth)
// - Needs: GraphQL Me query mock (app queries user data after auth)

// Logout Flow Investigation Result:
// - NO GraphQL mock needed! (app doesn't query)
// - Just wait for /logout endpoint call
```

### Step 4: Write Actions with Correct Selectors

**Validate every selector against the actual component.**

#### Selector Checklist

- [ ] Found the component in the codebase
- [ ] Checked what role it renders as (button, menuitem, link, etc.)
- [ ] Checked the accessible name (button text, aria-label, etc.)
- [ ] Verified conditional rendering requirements

#### Example: Writing clickSignOut

```typescript
// 1. Found component: ProfileNavContent.tsx
// 2. Saw: <MenuItem onClick={logout}><Body>{t('Sign Out')}</Body></MenuItem>
// 3. Know: MenuItem = role="menuitem", not "button"
// 4. Know: Text is i18n with t()

// ‚úÖ Correct action:
export const clickSignOut = async (page: Page) => {
  await page.getByRole('menuitem', { name: 'Sign Out' }).click()
}
```

### Step 5: Write Flows Based on Reality

**Match the actual app behavior, not what you think happens.**

```typescript
// Based on investigation: logout calls /logout endpoint, not GraphQL
export const logout = async (page: Page) => {
  await openUserMenu(page)
  await clickSignOut(page)
  
  // Wait for the ACTUAL endpoint called (not GraphQL!)
  await page.waitForResponse((r) => r.url().includes('/logout'))
  
  await page.waitForTimeout(500)  // Let UI update
}
```

### Step 6: Write Assertions That Match UI Behavior

**Verify what actually changes in the UI.**

```typescript
// Investigation: After logout, isLoggedIn becomes false via useEffect
// UI shows: Sign In button appears, ProfileAvatar hides

// ‚úÖ Dual-check approach:
export const expectUserLoggedOut = async (page: Page) => {
  // Check both conditions to be robust
  await expect(getSignInButton(page)).toBeVisible()
  await expect(getUserAvatar(page)).not.toBeVisible()
}
```

### Step 7: Set Up Mock Timing Correctly

**Mocks must be set up at the right time to match app flow.**

#### Browser-Level Mocks (Before page.goto)

```typescript
// Window objects MUST be set before page loads
test.beforeEach(async ({ page }) => {
  await page.addInitScript(() => {
    window.nostr = { /* mock */ }
  })
  await page.goto('/')  // Now components can detect window.nostr
})
```

#### State-Changing Mocks (During test flow)

```typescript
// GraphQL Me mock should happen AFTER opening auth popup
await clickSignIn(page)
await page.getByText('Connect').waitFor()

// NOW mock the logged-in user (before clicking auth button)
await mockGraphQLMe(page, loggedInUser)

await selectNostrAuth(page)
```

### Step 8: Validate with Tests

- Run the test
- Check screenshots/videos if it fails
- Verify the test matches the actual app behavior
- Update rules if you discover new patterns

---

## üö® When Tests Fail: Debugging Hierarchy

Follow this order to debug failures efficiently:

### 1. Check Screenshot/Video
- Is the element visible on the page?
- If NO ‚Üí Element doesn't exist (go to step 2)
- If YES ‚Üí Selector issue (go to step 5)

### 2. Check Component Code
- Find the component in codebase
- Look for conditional rendering (`if (!x) return null`)
- Check required prerequisites

### 3. Check Mock Timing
- Are browser-level mocks set up before `page.goto()`?
- Are state-changing mocks set up at the right time?

### 4. Check Prerequisites
- Window objects present?
- Authentication state correct?
- Required props/state available?

### 5. Check Selector (Only After 1-4)
- Verify the role (button, menuitem, link, etc.)
- Check accessible name in DevTools
- Try Playwright Inspector: `await page.pause()`

---

## üí° Critical Learnings from Real Bugs

### Don't Assume‚ÄîVerify

**Bug**: Logout test mocked GraphQL response that was never called.  
**Cause**: Assumed logout works like login (both use GraphQL). Never verified.  
**Fix**: Investigated `auth.tsx`, found logout only calls `/logout` endpoint.  
**Lesson**: Similar features may work completely differently. Investigate each independently.

### Check Element Existence Before Selector

**Bug**: Nostr button selector timeout.  
**Cause**: Assumed selector was wrong. Actually, button wasn't rendered (missing `window.nostr`).  
**Fix**: Moved `window.nostr` mock before `page.goto()`.  
**Lesson**: If element isn't in screenshot, don't debug the selector‚Äîdebug why it doesn't exist.

### Chakra UI Components Have Specific Roles

**Bug**: `getByRole('button', { name: 'Sign Out' })` didn't find MenuItem.  
**Cause**: Chakra `MenuItem` has `role="menuitem"`, not `role="button"`.  
**Fix**: Changed to `getByRole('menuitem')`.  
**Lesson**: Always check actual component to verify its accessibility role.

---

## üèóÔ∏è Architecture

### Domain-Driven Design Structure

```
packages/testing/playwright/
‚îú‚îÄ‚îÄ tests/{domain}/{feature}.spec.ts  # Test specifications
‚îú‚îÄ‚îÄ domains/{domain}/
‚îÇ   ‚îú‚îÄ‚îÄ actions.ts     # Atomic user interactions (click, type, select)
‚îÇ   ‚îú‚îÄ‚îÄ flows.ts       # Multi-step business workflows (login, checkout)
‚îÇ   ‚îú‚îÄ‚îÄ assertions.ts  # Verification functions (expectLoggedIn)
‚îÇ   ‚îú‚îÄ‚îÄ mocks.ts       # Mock setup (mockNostr, mockGraphQL)
‚îÇ   ‚îî‚îÄ‚îÄ fixtures.ts    # Test fixtures (authenticatedPage)
‚îî‚îÄ‚îÄ domains/shared/    # Cross-domain utilities
```

### File Naming

- **Actions**: `click{Thing}`, `enter{Thing}`, `select{Thing}`
- **Flows**: `{verb}{BusinessConcept}` (e.g., `loginWithNostr`)
- **Assertions**: `expect{Condition}` (e.g., `expectUserLoggedIn`)
- **Mocks**: `mock{Service}` or `setup{Service}Mocks`

---

## üé® Common Patterns in This Codebase

### Window Object Dependencies

```typescript
// ConnectWithNostr.tsx conditionally renders based on window.nostr
if (!window.nostr) return null

// Solution: Mock BEFORE page.goto
await page.addInitScript(() => { window.nostr = { ... } })
await page.goto('/')
```

### Chakra UI MenuItem

```typescript
// MenuItems have role="menuitem", not "button"
<MenuItem onClick={handler}><Body>{t('Text')}</Body></MenuItem>

// ‚úÖ Correct selector:
await page.getByRole('menuitem', { name: 'Text' })
```

### Internationalized Text

```typescript
// All user-facing text uses t() for i18n
<Button>{t('Sign in')}</Button>

// ‚úÖ Use exact text (translated in test env):
await page.getByRole('button', { name: 'Sign in' })
```

### Authentication States

```typescript
// Login: External auth ‚Üí GraphQL query
await mockGraphQLMe(page)  // App queries user data
await selectNostrAuth(page)
await page.waitForResponse((r) => r.url().includes('/graphql'))

// Logout: Local state clear ‚Üí REST call
await clickSignOut(page)
await page.waitForResponse((r) => r.url().includes('/logout'))
// No GraphQL query!
```

---

## üîß Selector Strategy

### Priority Order

1. **`getByRole()`** - Most semantic (button, menuitem, link, heading)
2. **`getByTestId()`** - Stable (add `data-testid` to components)
3. **`getByLabel()`** / **`getByPlaceholder()`** - Forms
4. **CSS selectors** - Last resort only

### Examples

```typescript
// Buttons
await page.getByRole('button', { name: 'Sign in' })

// Menu items (Chakra UI)
await page.getByRole('menuitem', { name: 'Sign Out' })

// Custom components with test IDs
await page.getByTestId('user-profile-avatar')

// Form inputs
await page.getByLabel('Email')
await page.getByPlaceholder('Enter amount')
```

---

## üé≠ Mocking

### What to Mock

‚úÖ **Mock**: Browser extensions, external auth, unstable services  
‚ùå **Don't Mock**: Your own API, local state, UI behavior

### Mock Timing

**Browser-Level Mocks** (before `page.goto()`):
- Window objects (`window.nostr`)
- Browser extensions
- Global configurations

**State-Changing Mocks** (during test flow):
- API responses that change based on user actions
- GraphQL queries that return different data

### Techniques

```typescript
// Window objects
await page.addInitScript(() => { window.nostr = { ... } })

// Network interception
await page.route('**/auth/nostr', async (route) => {
  await route.fulfill({ json: { token: 'test' } })
})

// GraphQL
await page.route('**/graphql', async (route) => {
  const body = route.request().postDataJSON()
  if (body.operationName === 'Me') {
    await route.fulfill({ json: { data: { me: mockUser } } })
  } else {
    await route.continue()
  }
})
```

---

## üß™ Test Structure

### Arrange-Act-Assert Pattern

```typescript
test('should complete donation', async ({ page }) => {
  // Arrange
  await page.goto('/project/test-project')
  await loginWithNostr(page)
  
  // Act
  const invoice = await completeDonation(page, 1000)
  await payInvoice(invoice)
  
  // Assert
  await expectSuccessScreen(page)
})
```

### Test Independence

- Each test is independent
- Use `beforeEach` for common setup
- Don't rely on test execution order
- Clean up test data

---

## üìö Quick Reference

### Commands

```bash
yarn test:playwright                    # Run all tests
yarn test:playwright:ui                 # UI mode (recommended)
yarn test:playwright:debug              # Debug mode
yarn test:playwright tests/auth/*.spec.ts  # Specific tests
```

### Debugging

```typescript
await page.pause()                      // Playwright Inspector
await page.screenshot({ path: 'debug.png' })
page.on('console', msg => console.log(msg.text()))
```

### Environment

Configure `.env.playwright`:
- `APP_URL` - Application URL
- `CONTRIBUTOR_LND_ENDPOINT` - Lightning node
- Additional Bitcoin/LND configuration as needed

---

## üé® Project-Specific Patterns

### Funding Flow Patterns

**Clipboard Handling:**
```typescript
// Grant clipboard permissions
await page.context().grantPermissions(['clipboard-read', 'clipboard-write'])

// Click copy button
await page.locator('#copy-lightning-invoice-button').click()

// Wait for clipboard
await page.waitForTimeout(500)

// Read clipboard
const invoice = await page.evaluate(async () => {
  return await navigator.clipboard.readText()
})
```

**Bitcoin Payment Testing:**
```typescript
// Lightning: Pay invoice via LND REST API
await payLightningInvoice(invoice)

// Onchain: Parse BIP21 URI and pay
const address = bip21Uri.split(':')[1]?.split('?')[0]
await payOnchain(address, amount)

// Mine block to confirm
await mineBlock()
```

**Onchain Success States:**
- **Processing**: Transaction sent, waiting for confirmations
  - Shows `#onchain-transaction-processing-card`
  - Success banner NOT visible yet
- **Intermediate Success**: Transaction detected (FundingSuccessIntermediate)
  - Shows `#successful-contribution-banner` with `isPending=true`
  - Before block confirmation
- **Final Success**: Transaction confirmed
  - Shows `#successful-contribution-banner`
  - After mining block

**Lightning vs Onchain Flow:**
- **Lightning**: Direct to final success (instant)
- **Onchain**: Processing ‚Üí Intermediate ‚Üí Final (requires mining)

---

## ‚úÖ AI Agent Checklist

### When Creating Test Plans

- [ ] Include "Investigate App Behavior" step
- [ ] Include "Verify UI Rendering" step
- [ ] Include "Identify Mocking Needs" step
- [ ] Ask clarifying questions if uncertain
- [ ] Don't assume based on old tests

### When Writing Tests

- [ ] Read actual component code
- [ ] Verify element roles and rendering
- [ ] Check network calls in implementation
- [ ] Validate mock timing
- [ ] Test assertions match reality

### When Debugging Failures

- [ ] Check screenshot first
- [ ] Verify element exists before fixing selector
- [ ] Investigate conditional rendering
- [ ] Check mock timing
- [ ] Only then try different selectors

### When Tests Pass

- [ ] Update rules with new patterns
- [ ] Document any new learnings
- [ ] Ensure code follows architecture
