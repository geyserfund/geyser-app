"""Add BigInt functionality"""
scalar BigInt

"""Date custom scalar type"""
scalar Date

interface MutationResponse {
  success: Boolean!
  message: String
}

type Query {
  _: Boolean
  projectGet(where: UniqueProjectQueryInput!): Project

  """By default, returns a list of all active projects."""
  projectsGet(input: ProjectsGetQueryInput): ProjectsResponse!
  projectRegionsGet: [ProjectRegionsGetResult!]!
  projectCountriesGet(input: ProjectCountriesGetInput): [ProjectCountriesGetResult!]!
  me: User
  user(where: UserGetInput!): User!
  userEmailIsAvailable(email: String!): Boolean!
  userIpCountry: String!
  statusCheck: Boolean!
  fundersGet(input: GetFundersInput!): [Funder!]!
  contributor(input: GetContributorInput!): Funder!
  getDashboardFunders(input: GetFundersInput): [Funder!]!
  contributionsGet(input: GetContributionsInput): ContributionsGetResponse
  contribution(id: BigInt): Contribution!
  currencyQuoteGet(input: CurrencyQuoteGetInput!): CurrencyQuoteGetResponse!
  projectLeaderboardContributorsGet(input: ProjectLeaderboardContributorsGetInput!): [ProjectLeaderboardContributorsRow!]!
  projectLeaderboardAmbassadorsGet(input: ProjectLeaderboardAmbassadorsGetInput!): [ProjectLeaderboardAmbassadorsRow!]!
  leaderboardGlobalContributorsGet(input: LeaderboardGlobalContributorsGetInput!): [GlobalContributorLeaderboardRow!]!
  leaderboardGlobalCreatorsGet(input: LeaderboardGlobalCreatorsGetInput!): [GlobalCreatorLeaderboardRow!]!
  leaderboardGlobalAmbassadorsGet(input: LeaderboardGlobalAmbassadorsGetInput!): [GlobalAmbassadorLeaderboardRow!]!
  leaderboardGlobalProjectsGet(input: LeaderboardGlobalProjectsGetInput!): [GlobalProjectLeaderboardRow!]!
  payment(input: PaymentGetInput!): Payment!
  getSignedUploadUrl(input: FileUploadInput!): SignedUploadUrl!
  getProjectReward(id: BigInt!): ProjectReward!
  projectRewardGet(input: GetProjectRewardInput!): ProjectReward!
  projectRewardsGet(input: GetProjectRewardsInput!): [ProjectReward!]!
  projectRewardCategoriesGet: [String!]!
  projectStatsGet(input: GetProjectStatsInput!): ProjectStats!
  projectsMostFundedByTag(input: ProjectsMostFundedByTagInput!): [ProjectMostFundedByTag!]!
  projectsMostFundedByCategory(input: ProjectsMostFundedByCategoryInput!): [ProjectMostFundedByCategory!]!
  projectsSummary: ProjectsSummary!
  projectGoal(projectGoalId: BigInt!): ProjectGoal!
  projectGoals(input: GetProjectGoalsInput!): ProjectGoals!

  """Returns all published posts"""
  posts(input: GetEntriesInput): [Post!]!
  post(id: BigInt!): Post
  postEmailSegmentSizeGet(input: PostEmailSegmentSizeGetInput!): Int!

  """Returns all published entries (deprecated, use posts instead)"""
  getEntries(input: GetEntriesInput): [Entry!]!
  entry(id: BigInt!): Entry
  getWallet(id: BigInt!): Wallet!

  """
  Returns the public key of the Lightning node linked to a project, if there is one.
  """
  getProjectPubkey(projectId: BigInt!): String @deprecated
  lightningAddressVerify(lightningAddress: String): LightningAddressVerifyResponse!

  """Returns all activities."""
  activitiesGet(input: GetActivitiesInput): ActivitiesGetResponse!
  activitiesCountGroupedByProject(input: ActivitiesCountGroupedByProjectInput!): [ProjectActivitiesCount!]!
  tagsGet: [TagsGetResult!]!
  tagsMostFundedGet: [TagsMostFundedGetResult!]!
  grant(input: GrantGetInput!): Grant!
  grants: [Grant!]!
  grantStatistics: GrantStatistics!
  badges: [Badge!]!
  userBadge(userBadgeId: BigInt!): UserBadge
  userBadges(input: BadgesGetInput!): [UserBadge!]!
  orderGet(where: UniqueOrderInput!): Order
  ordersGet(input: OrdersGetInput!): OrdersGetResponse
  guardianUsersGet(input: GuardianUsersGetInput!): GuardianUsersGetResponse
  userNotificationSettingsGet(userId: BigInt!): ProfileNotificationSettings!
  projectNotificationSettingsGet(projectId: BigInt!): CreatorNotificationSettings!
  paymentInvoiceSanctionCheckStatusGet(input: PaymentInvoiceSanctionCheckStatusGetInput!): PaymentInvoiceSanctionCheckStatusResponse!
  ordersStatsGet(input: GetProjectOrdersStatsInput!): OrdersStatsBase!
  projectRewardsTrendingWeeklyGet: [ProjectRewardTrendingWeeklyGetRow!]!
  projectRewardsTrendingMonthlyGet: [ProjectRewardTrendingMonthlyGetRow!]!
  userSubscription(id: BigInt!): UserSubscription
  userSubscriptions(input: UserSubscriptionsInput!): [UserSubscription!]!
  projectSubscriptionPlan(id: BigInt!): ProjectSubscriptionPlan
  projectSubscriptionPlans(input: ProjectSubscriptionPlansInput!): [ProjectSubscriptionPlan!]!
}

type Mutation {
  _: Boolean
  createProject(input: CreateProjectInput!): Project!
  updateProject(input: UpdateProjectInput!): Project!
  projectDelete(input: DeleteProjectInput!): ProjectDeleteResponse!
  projectTagAdd(input: ProjectTagMutationInput!): [Tag!]!
  projectTagRemove(input: ProjectTagMutationInput!): [Tag!]!
  projectFollow(input: ProjectFollowMutationInput!): Boolean!
  projectUnfollow(input: ProjectFollowMutationInput!): Boolean!
  projectStatusUpdate(input: ProjectStatusUpdate!): Project!
  projectPublish(input: ProjectPublishMutationInput!): Project!
  projectRewardCurrencyUpdate(input: ProjectRewardCurrencyUpdate!): [ProjectReward!]!
  updateUser(input: UpdateUserInput!): User!
  unlinkExternalAccount(id: BigInt!): User!
  userDelete: DeleteUserResponse!
  userEmailUpdate(input: UserEmailUpdateInput!): User!
  userEmailVerify(input: EmailVerifyInput!): Boolean!
  contributionEmailUpdate(input: ContributionEmailUpdateInput): Contribution!
  contributionCreate(input: ContributionCreateInput!): ContributionMutationResponse!
  contributionPaymentsAdd(input: ContributionPaymentsAddInput!): ContributionPaymentsAddResponse!
  podcastKeysendContributionCreate(input: PodcastKeysendContributionCreateInput!): PodcastKeysendContributionCreateResponse!
  paymentConfirm(input: PaymentConfirmInput!): PaymentConfirmResponse!
  paymentPend(input: PaymentPendInput!): PaymentPendResponse!
  paymentCancel(input: PaymentCancelInput!): PaymentCancelResponse!
  paymentFail(input: PaymentFailInput!): PaymentFailResponse!
  paymentInvoiceCancel(invoiceId: String!): PaymentInvoiceCancelResponse!
  projectRewardCreate(input: CreateProjectRewardInput!): ProjectReward!
  projectRewardUpdate(input: UpdateProjectRewardInput!): ProjectReward!

  """Soft deletes the reward."""
  projectRewardDelete(input: DeleteProjectRewardInput!): Boolean!

  """Only returns ProjectGoals that are in progress"""
  projectGoalOrderingUpdate(input: ProjectGoalOrderingUpdateInput!): [ProjectGoal!]!
  projectGoalDelete(projectGoalId: BigInt!): ProjectGoalDeleteResponse!
  projectGoalCreate(input: ProjectGoalCreateInput!): [ProjectGoal!]!
  projectGoalUpdate(input: ProjectGoalUpdateInput!): ProjectGoal!
  postCreate(input: PostCreateInput!): Post!
  postUpdate(input: PostUpdateInput!): Post!
  postPublish(input: PostPublishInput!): Post!
  postDelete(id: BigInt!): Post!
  postSendByEmail(input: PostSendByEmailInput!): PostSendByEmailResponse!
  createEntry(input: CreateEntryInput!): Entry! @deprecated(reason: "Use postCreate instead")
  updateEntry(input: UpdateEntryInput!): Entry! @deprecated(reason: "Use postUpdate instead")
  publishEntry(id: BigInt!): Entry! @deprecated(reason: "Use postPublish instead")
  deleteEntry(id: BigInt!): Entry! @deprecated(reason: "Use postDelete instead")

  """This operation is currently not supported."""
  walletUpdate(input: UpdateWalletInput!): Wallet!
  updateWalletState(input: UpdateWalletStateInput!): Wallet!
  walletCreate(input: CreateWalletInput!): Wallet!
  walletDelete(id: BigInt!): Boolean!
  tagCreate(input: TagCreateInput!): Tag!
  grantApply(input: GrantApplyInput): GrantApplicant!
  userBadgeAward(userBadgeId: BigInt!): UserBadge!
  claimBadge(input: BadgeClaimInput!): UserBadge!

  """
  Sends an OTP to the user's email address and responds with a token that can be used, together with the OTP, to two-factor authenticate
  a request made by the client.
  """
  sendOTPByEmail(input: SendOtpByEmailInput!): OTPResponse!
  orderStatusUpdate(input: OrderStatusUpdateInput!): Order
  userNotificationConfigurationValueUpdate(userNotificationConfigurationId: BigInt!, value: String!): Boolean
  creatorNotificationConfigurationValueUpdate(creatorNotificationConfigurationId: BigInt!, value: String!): Boolean
  userVerificationTokenGenerate(input: UserVerificationTokenGenerateInput!): UserVerificationTokenGenerateResponse!
  ambassadorPayoutConfirm(invoiceId: String!): AmbassadorPayoutConfirmResponse!
  ambassadorPayoutRequestGenerate(input: GenerateAmbassadorPayoutRequestsInput!): GenerateAmbassadorPayoutRequestResponse
  userSubscriptionUpdate(input: UpdateUserSubscriptionInput!): UserSubscription!
  userSubscriptionCancel(id: BigInt!): UserSubscription!
  projectSubscriptionPlanCreate(input: CreateProjectSubscriptionPlanInput!): ProjectSubscriptionPlan!
  projectSubscriptionPlanUpdate(input: UpdateProjectSubscriptionPlanInput!): ProjectSubscriptionPlan!
  projectSubscriptionPlanDelete(id: BigInt!): Boolean!
}

type Subscription {
  _: Boolean
  projectActivated: ProjectActivatedSubscriptionResponse!
  contributionStatusUpdated(input: ContributionStatusUpdatedInput): ContributionStatusUpdatedSubscriptionResponse!
  paymentStatusUpdated(input: PaymentStatusUpdatedInput!): Payment!
  postPublished: PostPublishedSubscriptionResponse!
  entryPublished: EntryPublishedSubscriptionResponse!
  activityCreated(input: ActivityCreatedSubscriptionInput): Activity!
}

type PaginationCursor {
  id: BigInt
}

type CursorPaginationResponse {
  cursor: PaginationCursor
  take: Int
  count: Int
}

"""Cursor pagination input."""
input PaginationInput {
  cursor: CursorInput
  take: Int
}

input CursorInput {
  id: BigInt!
}

input OffsetBasedPaginationInput {
  skip: Int
  take: Int
}

input DateRangeInput {
  startDateTime: Date
  endDateTime: Date
}

input TwoFAInput {
  OTP: OTPInput

  """TOTP is not supported yet."""
  TOTP: TOTPInput
}

input TOTPInput {
  totp: Int!
}

input OTPInput {
  otpVerificationToken: String!
  otp: Int!
}

enum OrderByOptions {
  asc
  desc
}

enum OrderByDirection {
  asc
  desc
}

type ProjectDeleteResponse implements MutationResponse {
  success: Boolean!
  message: String
}

input ProjectCountriesGetInput {
  category: ProjectCategory
  subCategory: ProjectSubCategory
}

input ProjectRewardCurrencyUpdate {
  projectId: BigInt!
  rewardCurrency: RewardCurrency!
}

input ProjectRewardCurrencyUpdateRewardsInput {
  rewardId: BigInt!
  cost: Int!
}

input DeleteProjectInput {
  projectId: BigInt!
}

input ProjectStatusUpdate {
  projectId: BigInt!
  status: ProjectStatus!
}

input ProjectLinkMutationInput {
  projectId: BigInt!
  link: String!
}

input ProjectFollowMutationInput {
  projectId: BigInt!
}

input ProjectPublishMutationInput {
  projectId: BigInt!
}

type ProjectRegionsGetResult {
  region: String!
  count: Int!
}

type ProjectCountriesGetResult {
  country: Country!
  count: Int!
}

input ProjectTagMutationInput {
  projectId: BigInt!
  tagId: Int!
}

type ProjectActivatedSubscriptionResponse {
  project: Project!
}

type Project {
  id: BigInt!

  """Public title of the project."""
  title: String!

  """
  Unique name for the project. Used for the project URL and lightning address.
  """
  name: String!

  """Description of the project."""
  description: String

  """Short description of the project."""
  shortDescription: String

  """Total amount raised by the project, in satoshis."""
  balance: Int!
  balanceUsdCent: Int!
  createdAt: String!
  updatedAt: String!
  launchedAt: Date
  thumbnailImage: String
  category: ProjectCategory
  subCategory: ProjectSubCategory

  """Project header images."""
  image: String @deprecated(reason: "Use images instead.")
  images: [String!]!
  status: ProjectStatus
  type: ProjectType!
  rewardCurrency: RewardCurrency
  links: [String!]!
  owners: [Owner!]!
  funders: [Funder!]!
  fundersCount: Int
  sponsors: [Sponsor!]! @deprecated
  ambassadors: ProjectAmbassadorsConnection!
  followers: [User!]!
  followersCount: Int
  rewards: [ProjectReward!]!
  contributions: [Contribution!]!
  contributionsCount: Int
  location: Location
  keys: ProjectKeys!

  """Wallets linked to a Project."""
  wallets: [Wallet!]!
  tags: [Tag!]!

  """Returns summary statistics on the Project views and visitors."""
  statistics: ProjectStatistics

  """Returns the project's grant applications."""
  grantApplications(input: ProjectGrantApplicationsInput): [GrantApplicant!]!

  """Boolean flag to indicate if the project can be deleted."""
  canDelete: Boolean!
  defaultGoalId: BigInt
  milestones: [Milestone!]! @deprecated(reason: "milestones are deprecated, use the goals instead")
  goalsCount: Int
  rewardsCount: Int
  entriesCount: Int
  rewardBuyersCount: Int
  subscribersCount: Int

  """
  By default, returns all the posts of a project, both published and unpublished but not deleted.
  To filter the result set, an explicit input can be passed that specifies a value of true or false for the published field.
  An unpublished post is only returned if the requesting user is the creator of the post.
  """
  posts(input: ProjectPostsGetInput): [Post!]!

  """
  By default, returns all the entries of a project, both published and unpublished but not deleted.
  To filter the result set, an explicit input can be passed that specifies a value of true or false for the published field.
  An unpublished entry is only returned if the requesting user is the creator of the entry.
  """
  entries(input: ProjectEntriesGetInput): [Entry!]!
  paymentMethods: PaymentMethods!
}

type Milestone {
  id: BigInt!
  name: String!
  description: String!
  amount: Int!
  reached: Boolean
}

type Country {
  code: String!
  name: String!
}

type Location {
  country: Country
  region: String
}

type Owner {
  id: BigInt!
  user: User!
}

type Ambassador {
  id: BigInt!
  user: User!
}

type User {
  """
  Returns the projects of a user. By default, this field returns all the projects for that user, both draft and non-draft.
  To filter the result set, an explicit input can be passed that specifies a value of the status field.
  """
  projects(input: UserProjectsGetInput): [Project!]!
  id: BigInt!
  username: String!
  heroId: String!
  imageUrl: String
  bio: String
  email: String
  isEmailVerified: Boolean!
  emailVerifiedAt: Date

  """
  External accounts linked to the User. It can be a twitter account if the User linked their account. For anonymous
  users, this field can contain the wallet or app from which they funded, eg: Fountain, Breeze, etc.
  """
  externalAccounts: [ExternalAccount!]!
  hasSocialAccount: Boolean!

  """Details on the participation of a User in a project."""
  projectContributions: [UserProjectContribution!]!
  ownerOf: [OwnerOf!]!
  projectFollows: [Project!]!
  wallet: Wallet
  badges: [UserBadge!]!
  orders: [Order!]
  heroStats: UserHeroStats!
  guardianType: GuardianType
  ranking: BigInt @deprecated(reason: "Use heroStats.rank instead")

  """Returns a user's contributions accross all projects."""
  contributions: [Contribution!]!

  """
  By default, returns all the posts of a user, both published and unpublished but not deleted. 
  To filter the result set, an explicit input can be passed that specifies a value of true or false for the published field.
  An unpublished post is only returned if the requesting user is the creator of the post.
  """
  posts(input: UserPostsGetInput): [Post!]!

  """
  By default, returns all the entries of a user, both published and unpublished but not deleted. 
  To filter the result set, an explicit input can be passed that specifies a value of true or false for the published field.
  An unpublished entry is only returned if the requesting user is the creator of the entry.
  """
  entries(input: UserEntriesGetInput): [Entry!]!
  complianceDetails: UserComplianceDetails!
}

type ProjectsSummary {
  """Total number of projects ever created on the platform."""
  projectsCount: Int

  """Total number of funders on the platform."""
  fundersCount: Int

  """Total of satoshis raised by projects on the platform."""
  fundedTotal: BigInt
}

type ProjectKeys {
  nostrKeys: NostrKeys!
}

type NostrKeys {
  publicKey: NostrPublicKey!
  privateKey: NostrPrivateKey
}

type NostrPublicKey {
  hex: String!
  npub: String!
}

type NostrPrivateKey {
  hex: String!
  nsec: String!
}

type ProjectsResponse {
  projects: [Project!]!
  summary: ProjectsSummary
}

type ProjectStatistics {
  totalVisitors: Int!
  totalPageviews: Int!
}

input UserProjectsGetInput {
  where: UserProjectsGetWhereInput
}

input UserProjectsGetWhereInput {
  status: ProjectStatus
}

input CreateProjectInput {
  """Public title of the project."""
  title: String!

  """Project header images"""
  images: [String!]!
  thumbnailImage: String
  name: String!

  """A short description of the project."""
  description: String!
  shortDescription: String
  type: ProjectType

  """
  The currency used to price rewards for the project. Currently only USDCENT supported.
  """
  rewardCurrency: RewardCurrency
  email: String!

  """Project ISO3166 country code"""
  countryCode: String

  """Project region"""
  region: String
}

input UpdateProjectInput {
  projectId: BigInt!

  """Public title of the project."""
  title: String

  """Project header images."""
  images: [String!]

  """Project thumbnail image."""
  thumbnailImage: String

  """Description of the project."""
  description: String

  """A short description of the project."""
  shortDescription: String
  type: ProjectType

  """
  The currency used to price rewards for the project. Currently only USDCENT supported. Should become an Enum.
  """
  rewardCurrency: RewardCurrency

  """Project ISO3166 country code"""
  countryCode: String

  """Project region"""
  region: String

  """Project links"""
  links: [String!]

  """Project category"""
  category: ProjectCategory

  """Project sub-category"""
  subCategory: ProjectSubCategory

  """
  Project name, used both for the project URL, project lightning address and NIP05.
  """
  name: String
}

input UniqueProjectQueryInput {
  id: BigInt

  """
  Unique name for the project. Used for the project URL and lightning address.
  """
  name: String

  """Project's Nostr Public Key in HEX format"""
  nostrPublicKey: String
}

input ProjectsGetQueryInput {
  where: ProjectsGetWhereInput!

  """
  Takes an array of Project OrderBy options. When passing multiple ordering options, each option must
  be passed in a separate object in the array. This ensures consistent ordering of the orderBy options in the 
  result set.
  """
  orderBy: [ProjectsOrderByInput!]
  pagination: PaginationInput
}

input ProjectsGetWhereInput {
  id: BigInt
  ids: [BigInt!]

  """
  Unique name for the project. Used for the project URL and lightning address.
  """
  name: String
  status: ProjectStatus
  type: ProjectType
  region: String
  countryCode: String
  tagIds: [Int!]
  search: String
  category: ProjectCategory
  subCategory: ProjectSubCategory
}

input ProjectsOrderByInput {
  field: ProjectsOrderByField!
  direction: OrderByDirection!
}

input ProjectGrantApplicationsInput {
  where: ProjectGrantApplicationsWhereInput!
}

input ProjectGrantApplicationsWhereInput {
  grantStatus: ProjectGrantApplicationsWhereInputEnum!
}

enum ProjectGrantApplicationsWhereInputEnum {
  FUNDING_OPEN
}

enum ProjectsOrderByField {
  launchedAt
  balance
}

enum Currency {
  USDCENT
}

enum ProjectType {
  grant
  donation
  reward
}

enum ProjectStatus {
  inactive
  active
  draft
  deleted
  in_review
  closed
}

enum RewardCurrency {
  USDCENT
  BTCSAT
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type ProjectAmbassadorsConnection {
  """Information about the pagination of ambassadors"""
  pageInfo: PageInfo!

  """List of ambassador edges"""
  edges: [ProjectAmbassadorEdge!]! @deprecated(reason: "This field is not implemented yet and will always return an empty array")

  """Aggregated data about ambassadors"""
  stats: ProjectAmbassadorsStats!
}

"""Edge type for Project ambassadors"""
type ProjectAmbassadorEdge {
  """The ambassador node"""
  node: Ambassador!

  """Cursor for pagination"""
  cursor: String!
}

"""Statistics about project ambassadors"""
type ProjectAmbassadorsStats {
  """Total number of ambassadors"""
  count: Int!

  """Total number of contributions enabled by ambassadors"""
  contributionsCount: Int!

  """Total amount in satoshis enabled by ambassadors"""
  contributionsSum: BigInt!
}

enum ProjectCategory {
  EDUCATION
  COMMUNITY
  CULTURE
  ADVOCACY
  TOOL
  CAUSE
  OTHER
}

enum ProjectSubCategory {
  COURSE
  CONTENT_CREATOR
  JOURNALISM
  BOOK
  PODCAST
  EVENT
  CIRCULAR_ECONOMY
  MEETUP
  HACKER_SPACE
  FILM
  ART
  GAME
  MUSIC
  COLLECTIBLE
  LEGAL_FUND
  LOBBY
  PROMOTION
  OS_SOFTWARE
  HARDWARE
  APP
  HUMANITARIAN
  FUNDRAISER
  TRAVEL
  MEDICAL
  OTHER
}

input OTPLoginInput {
  otpVerificationToken: String!
  otp: Int!
}

type DeleteUserResponse implements MutationResponse {
  success: Boolean!
  message: String
}

input UpdateUserInput {
  id: BigInt!
  username: String
  bio: String
  imageUrl: String
}

input UserEmailUpdateInput {
  email: String!

  """
  The two-factor authentication input is required if the user already has an email set.
  """
  twoFAInput: TwoFAInput
}

type ExternalAccount {
  id: BigInt!
  accountType: String!
  externalId: String!
  externalUsername: String!
  externalLink: String
  public: Boolean!
}

type OwnerOf {
  project: Project
  owner: Owner
}

type UserProjectContribution {
  """Boolean value indicating if the User was an ambassador of the project."""
  isAmbassador: Boolean! @deprecated

  """Boolean value indicating if the User funded the project."""
  isFunder: Boolean!

  """Boolean value indicating if the User was a sponsor for the project."""
  isSponsor: Boolean! @deprecated

  """
  Funder linked to the funding contribution. Only present if the contribution was a funding contribution.
  """
  funder: Funder

  """Project linked to the contributions."""
  project: Project!
}

type UserHeroStats {
  creatorStats: CreatorStats!
  ambassadorStats: AmbassadorStats!
  contributorStats: ContributorStats!
}

interface HeroStats {
  contributionsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  projectsCount: Int!
  rank: Int!
}

type ContributorStats implements HeroStats {
  contributionsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!

  """Number of projects contributed to by the User."""
  projectsCount: Int!
  rank: Int!
}

type AmbassadorStats implements HeroStats {
  contributionsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!

  """Number of projects shared by the User."""
  projectsCount: Int!
  rank: Int!
}

type CreatorStats implements HeroStats {
  contributionsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!

  """Number of projects created by the User."""
  projectsCount: Int!
  rank: Int!
}

input UserGetInput {
  id: BigInt
  heroId: String
}

input EmailVerifyInput {
  otpVerificationToken: String!
  otp: Int!
}

enum GuardianType {
  LEGEND
  KING
  KNIGHT
  WARRIOR
}

input ResourceInput {
  resourceId: String!
  resourceType: FundingResourceType!
}

enum FundingResourceType {
  activity
  project
  entry
  user
}

"""
The Funder type contains a User's funding details over a particular project.
"""
type Funder {
  id: BigInt!
  user: User
  orders: [Order!]!

  """
  Aggregate amount funded by a Funder over all his (confirmed) funding transactions for a particular project, in satoshis.
  """
  amountFunded: Int

  """Number of (confirmed) times a Funder funded a particular project."""
  timesFunded: Int

  """
  Boolean value indicating whether at least one of the funding transactions of the Funder were confirmed.
  """
  confirmed: Boolean!

  """
  Time at which the first confirmed funding transactions of the Funder was confirmed.
  """
  confirmedAt: Date

  """Funder's contributions."""
  contributions(input: GetContributorContributionsInput): [Contribution!]!

  """Contributor's rank in the project."""
  rank: Int

  """Contribution's funding summary, possibly in different time ranges."""
  contributionsSummary(period: ContributionsSummaryPeriod): ContributorContributionsSummary
}

type ContributorContributionsSummary {
  commentsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  contributionsCount: Int!
}

input GetContributorContributionsInput {
  where: GetContributorContributionsWhereInput
}

input GetContributorContributionsWhereInput {
  status: ContributionStatus
}

input GetContributorInput {
  projectId: BigInt!
  userId: BigInt!
}

input GetFundersInput {
  where: GetFunderWhereInput
  orderBy: GetFundersOrderByInput
  pagination: PaginationInput
}

input dashboardFundersGetInput {
  where: GetDashboardFundersWhereInput
  orderBy: GetFundersOrderByInput
  pagination: PaginationInput
}

input GetDashboardFundersWhereInput {
  confirmed: Boolean
  sourceResourceInput: ResourceInput
  projectId: BigInt
}

input GetFunderWhereInput {
  confirmed: Boolean
  sourceResourceInput: ResourceInput
  projectId: BigInt
  anonymous: Boolean
  dateRange: DateRangeInput
}

"""only one sort field can be used at one time"""
input GetFundersOrderByInput {
  amountFunded: OrderByOptions
  confirmedAt: OrderByOptions
}

enum ContributionsSummaryPeriod {
  WEEK
  MONTH
  ALL_TIME
}

type ContributionsGetResponse {
  contributions: [Contribution!]!
  pagination: CursorPaginationResponse
}

type ContributionStatusUpdatedSubscriptionResponse {
  contribution: Contribution!
}

type PaymentConfirmResponse {
  id: BigInt!
  success: Boolean!
}

type PaymentPendResponse {
  id: BigInt!
  success: Boolean!
}

type PodcastKeysendContributionCreateResponse {
  id: BigInt!
  success: Boolean!
}

type Contribution {
  id: BigInt!

  """
  Private reference code viewable only by the Funder and the ProjectOwner related to this Contribution
  """
  uuid: String
  amount: Int!
  donationAmount: Int!
  status: ContributionStatus!
  comment: String
  privateComment: String
  media: String
  createdAt: Date
  confirmedAt: Date
  funder: Funder!
  sourceResource: SourceResource
  projectId: BigInt!

  """Contributor's email address. Only visible to the project owner."""
  email: String

  """Creator's email address. Only visible to the contributor."""
  creatorEmail: String
  order: Order
  bitcoinQuote: BitcoinQuote
  isAnonymous: Boolean!
  projectGoalId: BigInt
  isSubscription: Boolean!
  payments: [Payment!]!
}

type Swap {
  json: String!
}

type BitcoinQuote {
  quoteCurrency: QuoteCurrency!
  quote: Float!
}

type ContributionMutationResponse {
  contribution: Contribution!
  payments: ContributionPaymentsDetails!
}

type ContributionPaymentsAddResponse {
  payments: ContributionPaymentsDetails!
}

type ContributionPaymentsDetails {
  fiat: ContributionFiatPaymentDetails
  fiatSwap: ContributionFiatSwapPaymentDetails
  onChainSwap: ContributionOnChainSwapPaymentDetails
  lightning: ContributionLightningPaymentDetails
}

type ContributionFiatPaymentDetails {
  stripeClientSecret: String!
}

type ContributionFiatSwapPaymentDetails {
  checkoutUrl: String!
}

type ContributionOnChainSwapPaymentDetails {
  address: String!
  swapJson: String!
}

type ContributionLightningPaymentDetails {
  lightningInvoiceId: String!
  paymentRequest: String!
}

type AmountSummary {
  total: Int!
  donationAmount: Int!
  shippingCost: Int!
  rewardsCost: Int!
}

input ContributionCreateInput {
  projectId: BigInt!
  ambassadorHeroId: String
  projectGoalId: BigInt

  """
  Set to true if the funder wishes to remain anonymous. The user will still be associated to the contribution.
  """
  anonymous: Boolean!
  donationAmount: Int!
  orderInput: OrderContributionInput
  metadataInput: ContributionMetadataInput
  paymentsInput: ContributionPaymentsInput

  """The resource from which the contribution is being created."""
  sourceResourceInput: ResourceInput!
}

input ContributionPaymentsInput {
  fiat: ContributionFiatPaymentDetailsInput
  fiatSwap: ContributionFiatSwapPaymentDetailsInput
  onChainSwap: ContributionOnChainSwapPaymentDetailsInput
  lightning: ContributionLightningPaymentDetailsInput
}

input ContributionPaymentsAddInput {
  contributionId: BigInt!
  paymentsInput: ContributionPaymentsInput!
}

input ContributionFiatPaymentDetailsInput {
  create: Boolean
  stripe: ContributionFiatPaymentDetailsStripeInput!
}

input ContributionFiatSwapPaymentDetailsInput {
  create: Boolean
  banxa: ContributionFiatSwapPaymentDetailsBanxaInput!
}

input ContributionOnChainSwapPaymentDetailsInput {
  create: Boolean
  boltz: ContributionFiatSwapPaymentDetailsBoltzInput!
}

input ContributionLightningPaymentDetailsInput {
  zapRequest: String
  create: Boolean
}

input ContributionFiatPaymentDetailsStripeInput {
  returnUrl: String!
}

input ContributionFiatSwapPaymentDetailsBanxaInput {
  fiatCurrency: String!
  returnUrl: String!
}

input ContributionFiatSwapPaymentDetailsBoltzInput {
  swapPublicKey: String!
}

input ContributionMetadataInput {
  email: String
  comment: String
  media: String
  privateComment: String
  followProject: Boolean
  subscribeToGeyserEmails: Boolean
}

input StripeCheckoutSessionInput {
  returnUrl: String!
}

input OrderContributionInput {
  """
  Quote used client-side to compute the order total. That quote will be used unless the slippage exceeds
  a pre-defined threshold.
  """
  bitcoinQuote: OrderBitcoinQuoteInput
  items: [OrderItemInput!]!
}

input OrderBitcoinQuoteInput {
  quote: Float!
  quoteCurrency: QuoteCurrency!
}

input CurrencyQuoteGetInput {
  baseCurrency: BaseCurrency!
  quoteCurrency: QuoteCurrency!
}

type CurrencyQuoteGetResponse {
  quote: Float!
  baseCurrency: BaseCurrency!
  quoteCurrency: QuoteCurrency!
  timestamp: Date!
}

enum BaseCurrency {
  BTC
}

enum QuoteCurrency {
  USD
}

input OrderItemInput {
  itemId: BigInt!
  itemType: OrderItemType!

  """Number of times a reward was selected."""
  quantity: Int!
}

enum OrderItemType {
  PROJECT_REWARD
  PROJECT_SUBSCRIPTION_PLAN
}

input GetContributionsInput {
  where: GetContributionsWhereInput
  orderBy: GetContributionsOrderByInput
  pagination: PaginationInput
}

input GetContributionsWhereInput {
  dateRange: DateRangeInput
  sourceResourceInput: ResourceInput
  projectId: BigInt
  funderId: BigInt
  status: ContributionsWhereContributionStatus
  NOT: GetContributionsWhereInput
  OR: [GetContributionsWhereInput]
}

input GetContributionsOrderByInput {
  createdAt: OrderByOptions!
}

input SubscriptionPaymentConfirmationInput {
  userSubscriptionUuid: String!
  stripeSubscriptionId: String
}

input PaymentConfirmInput {
  amount: Int!
  amountCurrency: AmountCurrency!
  uuid: String
  invoiceId: String
  subscription: SubscriptionPaymentConfirmationInput
}

input PodcastKeysendContributionCreateInput {
  projectId: BigInt!
  amount: Int!
  paidAt: Date!
  appName: String!
  externalUsername: String
  externalId: String
  comment: String
  privateComment: String
}

input ContributionStatusUpdatedInput {
  projectId: BigInt
  contributionId: BigInt
}

input ContributionEmailUpdateInput {
  contributionId: BigInt!
  email: String!
}

type GlobalProjectLeaderboardRow {
  projectName: String!
  projectTitle: String!
  projectThumbnailUrl: String
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  contributionsCount: Int!
  contributorsCount: Int!
}

type GlobalCreatorLeaderboardRow {
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  projectsCount: Int!
  userId: BigInt!
  username: String!
  userImageUrl: String
  userHeroId: String
  userGuardianType: GuardianType
}

type GlobalContributorLeaderboardRow {
  contributionsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  projectsContributedCount: Int!
  userId: BigInt!
  username: String!
  userImageUrl: String
  userHeroId: String
  userGuardianType: GuardianType
}

type GlobalAmbassadorLeaderboardRow {
  projectsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  userId: BigInt!
  username: String!
  userImageUrl: String
  userHeroId: String
  userGuardianType: GuardianType
}

type ProjectLeaderboardContributorsRow {
  commentsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  contributionsCount: Int!
  funderId: BigInt!
  user: User
}

input ProjectLeaderboardContributorsGetInput {
  projectId: BigInt!
  period: ProjectLeaderboardPeriod!
  top: Int!
}

input ProjectLeaderboardAmbassadorsGetInput {
  projectId: BigInt!
  period: ProjectLeaderboardPeriod!
  top: Int!
}

type ProjectLeaderboardAmbassadorsRow {
  projectsCount: Int!
  contributionsTotal: Int!
  contributionsTotalUsd: Float!
  contributionsCount: Int!
  user: User
}

input LeaderboardGlobalProjectsGetInput {
  """The period to return the leaderboard for."""
  period: LeaderboardPeriod!

  """The number of top projects to return."""
  top: Int!
}

input LeaderboardGlobalContributorsGetInput {
  """The period to return the leaderboard for."""
  period: LeaderboardPeriod!

  """The number of top contributors to return."""
  top: Int!
}

input LeaderboardGlobalCreatorsGetInput {
  """The period to return the leaderboard for."""
  period: LeaderboardPeriod!

  """The number of top contributors to return."""
  top: Int!
}

input LeaderboardGlobalAmbassadorsGetInput {
  """The period to return the leaderboard for."""
  period: LeaderboardPeriod!

  """The number of top contributors to return."""
  top: Int!
}

enum ProjectLeaderboardPeriod {
  WEEK
  MONTH
  ALL_TIME
}

enum LeaderboardPeriod {
  MONTH
  ALL_TIME
}

enum LightningInvoiceStatus {
  UNPAID
  PAID
  CANCELED
}

enum ContributionsWhereContributionStatus {
  CONFIRMED
}

enum ContributionStatus {
  PENDING
  CONFIRMED
}

enum ShippingDestination {
  national
  international
}

enum AmountCurrency {
  USDCENT
  BTCSAT
}

enum PaymentCurrency {
  USDCENT
  BTCSAT
}

enum PayoutCurrency {
  USDCENT
  BTCSAT
}

union SourceResource = Project | Entry | Activity

input PaymentStatusUpdatedInput {
  contributionUUID: String
}

input PaymentGetInput {
  onChainSwapId: String
  invoiceId: String
}

input PaymentPendInput {
  amount: Int!
  amountCurrency: AmountCurrency!
  uuid: String
  invoiceId: String
  onChainSwap: PaymentPendOnChainSwapInput
}

input PaymentPendOnChainSwapInput {
  tx: OnChainTxInput
}

input OnChainTxInput {
  id: String!
}

type PaymentInvoiceCancelResponse {
  id: BigInt!
  success: Boolean!
}

input PaymentCancelInput {
  id: BigInt
  uuid: String
  invoiceId: String
}

type PaymentCancelResponse {
  id: BigInt!
  success: Boolean!
}

input PaymentFailInput {
  uuid: String
  invoiceId: String
  failureReason: String
}

type PaymentFailResponse {
  id: BigInt!
  success: Boolean!
}

type Payment {
  id: BigInt!
  status: PaymentStatus!
  uuid: String!
  createdAt: Date!
  updatedAt: Date!
  paidAt: Date
  canceledAt: Date
  projectId: BigInt!
  funder: Funder!
  contributionUUID: String!
  baseAccountingAmount: Int!
  accountingAmountDue: Int!
  accountingAmountPaid: Int!
  paymentAmount: Int!
  paymentCurrency: PaymentCurrency!
  payoutAmount: Int!
  payoutCurrency: PayoutCurrency!
  failureReason: String
  version: Int!
  contributionPodcastKeysendId: BigInt
  userSubscriptionId: BigInt
  ambassadorUserId: BigInt
  method: String
  paymentDetails: PaymentDetails!
  fees: [PaymentFee!]!
}

type PaymentFee {
  feeAmount: Int!
  feeCurrency: FeeCurrency!
  feeType: PaymentFeeType
  feePayer: PaymentFeePayer
  external: Boolean
  description: String
}

enum PaymentFeeType {
  PLATFORM
  AMBASSADOR
  PARTNER
  PAYMENT
}

enum PaymentFeePayer {
  CONTRIBUTOR
  CREATOR
}

enum FeeCurrency {
  BTCSAT
  USDCENT
}

union PaymentDetails = LightningPaymentDetails | OnChainSwapPaymentDetails | FiatSwapPaymentDetails

type LightningPaymentDetails {
  lightningInvoiceId: String!
  lightningInvoiceStatus: LightningInvoiceStatus!
  zapRequest: String
}

type OnChainSwapPaymentDetails {
  swapId: String!
  onChainAddress: String!
  onChainTxId: String
  lightningInvoiceId: String!
  lightningInvoiceStatus: LightningInvoiceStatus!
}

type FiatSwapPaymentDetails {
  swapId: String!
  lightningInvoiceId: String!
  lightningInvoiceStatus: LightningInvoiceStatus!
}

enum PaymentStatus {
  UNPAID
  PENDING
  PARTIALLY_PAID
  PAID
  CANCELED
}

type SignedUploadUrl {
  """Signed URL used by the client to upload an image"""
  uploadUrl: String!

  """Distribution URL from which the image will be served"""
  distributionUrl: String!
}

input FileUploadInput {
  name: String

  """MIME type of the file. Currently only supports image types."""
  type: String
}

enum PrivateCommentPrompt {
  NOSTR_NPUB
  LIGHTNING_ADDRESS
  PROJECT_REWARD_SPECS
}

type ProjectReward {
  id: BigInt!

  """Name of the reward."""
  name: String!

  """Short description of the reward."""
  description: String

  """Short description of the reward."""
  shortDescription: String

  """Cost of the reward, priced in USD cents."""
  cost: Int!

  """Project reward images."""
  image: String @deprecated(reason: "Use images instead.")
  images: [String!]!

  """
  Whether the reward is deleted or not. Deleted rewards should not appear in the funding flow. Moreover, deleted 
  rewards should only be visible by the project owner and the users that purchased it.
  """
  deleted: Boolean!

  """Tracks the stock of the reward"""
  stock: Int

  """Number of times this Project Reward was sold."""
  sold: Int!

  """Boolean value to indicate whether this reward requires shipping"""
  project: Project!

  """Boolean value to indicate whether this reward requires shipping"""
  hasShipping: Boolean!

  """Boolean value to indicate whether this reward is an addon"""
  isAddon: Boolean!

  """Boolean value to indicate whether this reward is hidden"""
  isHidden: Boolean!

  """
  Boolean value to indicate whether this reward is in development or ready to ship
  """
  preOrder: Boolean!

  """The date the creator created the reward"""
  createdAt: Date!

  """The last date when the creator has updated the reward"""
  updatedAt: Date!

  """Internally used to track whether a reward was soft deleted"""
  deletedAt: Date

  """Estimated delivery time from the time of purchase"""
  estimatedDeliveryInWeeks: Int

  """Estimated availability date of a reward that is in development"""
  estimatedAvailabilityDate: Date

  """Maximum times the item can be purchased"""
  maxClaimable: Int

  """Category of ProjectReward"""
  category: String

  """Currency in which the reward cost is stored."""
  rewardCurrency: RewardCurrency!

  """
  UUID for the reward, it stays consistent throughout the project reward updates (the ID does not)
  """
  uuid: String!

  """Private comment prompts for the reward"""
  privateCommentPrompts: [PrivateCommentPrompt!]!

  """Confirmation message for the reward"""
  confirmationMessage: String

  """Posts for the reward"""
  posts: [Post!]!
  soldOut: Boolean!
  sentByEmailAt: Date
}

input GetProjectRewardsInput {
  where: GetProjectRewardsWhereInput!
}

input GetProjectRewardInput {
  where: GetProjectRewardWhereInput!
}

input GetProjectRewardsWhereInput {
  projectId: BigInt!
  deleted: Boolean
  dateRange: DateRangeInput
}

input GetProjectRewardWhereInput {
  id: BigInt
  uuid: String
}

input CreateProjectRewardInput {
  projectId: BigInt!
  name: String!
  description: String
  shortDescription: String

  """Cost of the reward, currently only in USD cents"""
  cost: Int!
  images: [String!]!
  hasShipping: Boolean!
  estimatedDeliveryInWeeks: Int
  estimatedAvailabilityDate: Date
  maxClaimable: Int
  category: String
  isAddon: Boolean
  isHidden: Boolean
  preOrder: Boolean
  privateCommentPrompts: [PrivateCommentPrompt!]!
  confirmationMessage: String
}

input UpdateProjectRewardInput {
  projectRewardId: BigInt!
  name: String
  description: String
  shortDescription: String

  """Cost of the reward, priced in USD cents"""
  cost: Int
  images: [String!]
  hasShipping: Boolean
  maxClaimable: Int
  category: String
  isAddon: Boolean
  isHidden: Boolean
  preOrder: Boolean
  estimatedAvailabilityDate: Date
  estimatedDeliveryInWeeks: Int
  privateCommentPrompts: [PrivateCommentPrompt!]
  confirmationMessage: String
}

input DeleteProjectRewardInput {
  projectRewardId: BigInt!
}

input ProjectsMostFundedByTagInput {
  range: ProjectsMostFundedByTagRange!
  take: Int
  tagIds: [Int!]!
}

input ProjectsMostFundedByCategoryInput {
  range: ProjectsMostFundedByCategoryRange!
  take: Int
  category: String
  subCategory: String
}

type ProjectMostFunded {
  """The project details"""
  project: Project!
}

type ProjectMostFundedByTag {
  tagId: Int!
  projects: [ProjectMostFunded!]!
}

type ProjectMostFundedByCategory {
  category: String
  subCategory: String
  projects: [ProjectMostFunded!]!
}

type DatetimeRange {
  """The start datetime for filtering the data."""
  startDateTime: Date!

  """The end datetime for filtering the data, default is now."""
  endDateTime: Date
}

interface GraphData {
  dateTime: Date!
  value: Int!
}

interface GraphSumData {
  dateTime: Date!
  sum: Int!
}

type FunderRewardGraphSum implements GraphSumData {
  dateTime: Date!
  sum: Int!
  rewardId: BigInt!
  rewardName: String!
}

type ProjectFunderStats {
  """Project contributors count in the given datetime range."""
  count: Int!
}

type ProjectFunderRewardStats {
  """Project rewards sold count in the given datetime range."""
  quantitySum: Int!

  """
  Project rewards sold count over the given datetime range grouped by day, or month.
  """
  quantityGraph: [FunderRewardGraphSum]
}

type PageViewCountGraph {
  dateTime: Date!
  viewCount: Int!
  visitorCount: Int!
}

type ProjectViewBaseStats {
  viewCount: Int!
  visitorCount: Int!
  value: String!
}

type ProjectViewStats {
  """Project view count in the given datetime range."""
  viewCount: Int!

  """Project visitor count in the given datetime range."""
  visitorCount: Int!

  """
  Project view/visitor count of each viewing country in the given datetime range.
  """
  countries: [ProjectViewBaseStats!]!

  """
  Project view/visitor count of each viewing region in the given datetime range.
  """
  regions: [ProjectViewBaseStats!]!

  """
  Project view/visitor count of each refferal platform in the given datetime range.
  """
  referrers: [ProjectViewBaseStats!]!

  """
  Project views/visitors count over the given datetime range grouped by day, or month.
  """
  visitorGraph: [PageViewCountGraph]!
}

type ProjectStatsBase {
  projectFunders: ProjectFunderStats @deprecated(reason: "will be deprecated")
  projectFunderRewards: ProjectFunderRewardStats @deprecated(reason: "will be deprecated")
  projectViews: ProjectViewStats @deprecated(reason: "will be deprecated")
  projectFollowers: ProjectFollowerStats @deprecated(reason: "will be deprecated")
  projectContributionsStats: ProjectContributionsStatsBase
}

type ProjectContributionsStatsBase {
  contributions: ProjectContributionsStats!
  contributionsGroupedByMethod: [ProjectContributionsGroupedByMethodStats!]!
}

interface StatsInterface {
  total: Int!
  totalUsd: Float!
  count: Int!
}

type ProjectContributionsStatsGraphDataAmount implements GraphData {
  dateTime: Date!
  value: Int!
}

enum ProjectContributionsStatsGraphDataStatType {
  SUM
}

type ProjectContributionsStatsGraphData {
  statType: ProjectContributionsStatsGraphDataStatType!
  graphData: [ProjectContributionsStatsGraphDataAmount!]
}

type ProjectContributionsStats implements StatsInterface {
  count: Int!
  total: Int!
  totalUsd: Float!

  """
  Project contribution over the given datetime range grouped by day, or month.
  """
  graph: [ProjectContributionsStatsGraphData!]!
}

type ProjectContributionsGroupedByMethodStats implements StatsInterface {
  method: String!
  total: Int!
  totalUsd: Float!
  count: Int!
}

type ProjectFollowerStats {
  count: Int!
}

type ProjectStats {
  current: ProjectStatsBase
  prevTimeRange: ProjectStatsBase
  datetimeRange: DatetimeRange!
}

input GetProjectStatsInput {
  where: GetProjectStatsWhereInput!
}

input GetProjectStatsWhereInput {
  projectId: BigInt!
  dateRange: DateRangeInput
  groupBy: AnalyticsGroupByInterval
}

enum AnalyticsGroupByInterval {
  day
  week
  month
  year
}

enum ProjectsMostFundedByTagRange {
  WEEK
}

enum ProjectsMostFundedByCategoryRange {
  WEEK
}

type ProjectGoalDeleteResponse implements MutationResponse {
  success: Boolean!
  message: String
}

input GetProjectGoalsInput {
  projectId: BigInt!
  receivedContributionsInDatetimeRange: DateRangeInput
}

input ProjectGoalOrderingUpdateInput {
  projectId: BigInt!
  projectGoalIdsOrder: [BigInt!]!
}

input ProjectGoalUpdateInput {
  projectGoalId: BigInt!
  title: String
  description: String
  targetAmount: Int
  currency: ProjectGoalCurrency
  emojiUnifiedCode: String
}

input ProjectGoalCreateInput {
  title: String!
  description: String
  targetAmount: Int!
  currency: ProjectGoalCurrency!
  projectId: BigInt!
  emojiUnifiedCode: String
}

type ProjectGoal {
  id: BigInt!
  title: String!
  description: String
  targetAmount: Int!
  currency: ProjectGoalCurrency!
  status: ProjectGoalStatus!
  emojiUnifiedCode: String
  projectId: BigInt!
  amountContributed: Int!
  progress: Float!
  completedAt: Date
  createdAt: Date!
  updatedAt: Date!
  hasReceivedContribution: Boolean!
  posts: [Post!]!
}

type ProjectGoals {
  inProgress: [ProjectGoal!]!
  completed: [ProjectGoal!]!
}

enum ProjectGoalCurrency {
  BTCSAT
  USDCENT
}

enum ProjectGoalStatus {
  IN_PROGRESS
  COMPLETED
}

enum ProjectGoalStatusInCreate {
  INACTIVE
  IN_PROGRESS
}

type PostPublishedSubscriptionResponse {
  post: Post!
}

type Post {
  id: BigInt!

  """Title of the Post."""
  title: String!

  """Short description of the Post."""
  description: String!

  """Header image of the Post."""
  image: String
  markdown: String
  createdAt: String!
  updatedAt: String!
  publishedAt: String
  postType: PostType

  """User that created the Post."""
  creator: User!

  """Project within which the Post was created."""
  project: Project

  """Contributions that were created from the Post's page."""
  contributions: [Contribution!]!

  """Number of funders that were created from the Post's page."""
  fundersCount: Int!

  """Total amount of satoshis funded from the Post's page."""
  amountFunded: Int!
  status: PostStatus!

  """Rewards linked to this Post."""
  projectRewards: [ProjectReward!]!

  """Goals linked to this Post."""
  projectGoals: ProjectGoals!

  """Date when the Post was sent by email."""
  sentByEmailAt: Date
}

input PostCreateInput {
  """Title of the Post."""
  title: String!

  """Short description of the Post."""
  description: String!

  """Header image of the Post."""
  image: String
  markdown: String
  projectId: BigInt!
  postType: PostType
  projectGoalIds: [BigInt!]!
  projectRewardUUIDs: [String!]!
}

input PostUpdateInput {
  postId: BigInt!
  title: String
  description: String

  """Header image of the Entry."""
  image: String
  markdown: String
  postType: PostType
  projectGoalIds: [BigInt!]!
  projectRewardUUIDs: [String!]!
}

input PostPublishInput {
  postId: BigInt!
  emailSendOptions: EmailSendOptionsInput
}

input PostGetInput {
  where: PostGetWhereInput
  orderBy: PostGetOrderByInput
  pagination: PaginationInput
}

input PostGetWhereInput {
  projectId: BigInt
}

input PostGetOrderByInput {
  publishedAt: OrderByOptions
}

input UserPostsGetInput {
  where: UserPostsGetWhereInput
}

input PostSendByEmailInput {
  postId: BigInt!
  emailSendOptions: EmailSendOptionsInput!
}

input EmailSendOptionsInput {
  segment: EmailSubscriberSegment!
  projectRewardUUIDs: [String!]
}

input PostEmailSegmentSizeGetInput {
  projectId: BigInt!
  emailSendOptions: EmailSendOptionsInput!
}

input UserPostsGetWhereInput {
  published: Boolean
}

input ProjectPostsGetInput {
  where: ProjectPostsGetWhereInput
}

input ProjectPostsGetWhereInput {
  published: Boolean
}

type PostSendByEmailResponse {
  recipientCount: Int
}

enum EmailSubscriberSegment {
  FOLLOWERS
  CONTRIBUTORS
  REWARD_BUYERS
}

enum PostStatus {
  published
  unpublished
  deleted
}

enum PostType {
  REWARD_UPDATE
  GOAL_UPDATE
  GOAL_REACHED
  ANNOUNCEMENT
  BEHIND_THE_SCENES
  FEEDBACK_REQUEST
  NEW_GOAL
  NEW_REWARD
  IMPACT
}

type EntryPublishedSubscriptionResponse {
  entry: Entry!
}

input GetEntriesInput {
  where: GetEntriesWhereInput
  orderBy: GetEntriesOrderByInput
  pagination: PaginationInput
}

input GetEntriesWhereInput {
  projectId: BigInt
}

input GetEntriesOrderByInput {
  publishedAt: OrderByOptions
}

input UserEntriesGetInput {
  where: UserEntriesGetWhereInput
}

input UserEntriesGetWhereInput {
  published: Boolean
}

input ProjectEntriesGetInput {
  where: ProjectEntriesGetWhereInput
}

input ProjectEntriesGetWhereInput {
  published: Boolean
}

enum EntryStatus {
  published
  unpublished
  deleted
}

type Entry {
  id: BigInt!

  """Title of the Entry."""
  title: String!

  """Short description of the Entry."""
  description: String!

  """Header image of the Entry."""
  image: String
  content: String
  markdown: String
  createdAt: String!
  updatedAt: String!
  publishedAt: String
  type: EntryType!

  """User that created the Entry."""
  creator: User!

  """Project within which the Entry was created."""
  project: Project

  """Contributions that were created from the Entry's page."""
  contributions: [Contribution!]!

  """Number of funders that were created from the Entry's page."""
  fundersCount: Int!

  """Total amount of satoshis funded from the Entry page."""
  amountFunded: Int!
  status: EntryStatus!
}

input CreateEntryInput {
  """Title of the Entry."""
  title: String!

  """Short description of the Entry."""
  description: String!

  """Header image of the Entry."""
  image: String
  content: String
  markdown: String
  type: EntryType!
  projectId: BigInt!
}

input UpdateEntryInput {
  entryId: BigInt!
  title: String
  description: String

  """Header image of the Entry."""
  image: String
  content: String
  markdown: String
}

enum EntryType {
  article
  podcast
  video
}

input CreateWalletInput {
  name: String
  feePercentage: Float!
  resourceInput: WalletResourceInput!
  lndConnectionDetailsInput: LndConnectionDetailsCreateInput
  lightningAddressConnectionDetailsInput: LightningAddressConnectionDetailsCreateInput
  nwcConnectionDetailsInput: NWCConnectionDetailsCreateInput
}

input WalletResourceInput {
  resourceId: BigInt!
  resourceType: WalletResourceType!
}

input UpdateWalletInput {
  id: BigInt!
  name: String
  feePercentage: Float
  lndConnectionDetailsInput: LndConnectionDetailsUpdateInput
  lightningAddressConnectionDetailsInput: LightningAddressConnectionDetailsUpdateInput
  nwcConnectionDetailsInput: NWCConnectionDetailsUpdateInput
  twoFAInput: TwoFAInput
}

input UpdateWalletStateInput {
  walletId: BigInt!
  status: WalletStatus!
  statusCode: WalletStatusCode!
}

input LightningAddressConnectionDetailsCreateInput {
  lightningAddress: String!
}

input LightningAddressConnectionDetailsUpdateInput {
  lightningAddress: String!
}

input NWCConnectionDetailsCreateInput {
  nwcUrl: String!
}

input NWCConnectionDetailsUpdateInput {
  nwcUrl: String!
}

input LndConnectionDetailsUpdateInput {
  """Invoice macaroon for authenticating gRPC calls to the LND node."""
  macaroon: String

  """TLS certificate for the LND node (optional for Voltage nodes)."""
  tlsCertificate: String

  """Hostname where the gRPC calls should be made."""
  hostname: String

  """Port where the gRPC calls should be made."""
  grpcPort: Int

  """Public key of the LND node."""
  pubkey: String

  """Type of the LND node."""
  lndNodeType: LndNodeType
}

input LndConnectionDetailsCreateInput {
  """Invoice macaroon for authenticating gRPC calls to the LND node."""
  macaroon: String!

  """TLS certificate for the LND node (optional for Voltage nodes)."""
  tlsCertificate: String

  """Hostname where the gRPC calls should be made."""
  hostname: String!

  """Port where the gRPC calls should be made."""
  grpcPort: Int!
  lndNodeType: LndNodeType!

  """Public key of the LND node."""
  pubkey: String
}

interface LndConnectionDetails {
  """Invoice macaroon for authenticating gRPC calls to the LND node."""
  macaroon: String!

  """TLS certificate for the LND node (optional for Voltage nodes)."""
  tlsCertificate: String

  """Hostname where the gRPC calls should be made."""
  hostname: String!

  """Port where the gRPC calls should be made."""
  grpcPort: Int!
  lndNodeType: LndNodeType!
}

type LightningAddressConnectionDetails {
  lightningAddress: String!
}

"""Public node details visible by anyone."""
type LndConnectionDetailsPublic {
  pubkey: String
}

"""Private node details that can only be queried by the wallet owner."""
type LndConnectionDetailsPrivate {
  """Invoice macaroon for authenticating gRPC calls to the LND node."""
  macaroon: String!

  """TLS certificate for the LND node (optional for Voltage nodes)."""
  tlsCertificate: String

  """Hostname where the gRPC calls should be made."""
  hostname: String!

  """Port where the gRPC calls should be made."""
  grpcPort: Int!

  """Type of the LND node used."""
  lndNodeType: LndNodeType!

  """Public key of the LND node."""
  pubkey: String
}

type NWCConnectionDetailsPrivate {
  nwcUrl: String
}

type NWCConnectionDetailsPublic {
  nwcUrl: String
}

type LightningAddressVerifyResponse {
  valid: Boolean!
  limits: LightningAddressContributionLimits
  reason: String
}

type LightningAddressContributionLimits {
  min: Int
  max: Int
}

type Wallet {
  id: BigInt!

  """Wallet name"""
  name: String
  connectionDetails: ConnectionDetails!
  state: WalletState!

  """The fee percentage applied to contributions going to this wallet."""
  feePercentage: Float

  """Funding limits on this wallet"""
  limits: WalletLimits
}

type WalletLimits {
  contribution: WalletContributionLimits
}

type WalletContributionLimits {
  min: Int
  max: Int
  onChain: WalletOnChainContributionLimits
  offChain: WalletOffChainContributionLimits
}

type WalletOnChainContributionLimits {
  min: Int
  max: Int
}

type WalletOffChainContributionLimits {
  min: Int
  max: Int
}

union ConnectionDetails = LndConnectionDetailsPrivate | LndConnectionDetailsPublic | LightningAddressConnectionDetails | NWCConnectionDetailsPrivate

enum LndNodeType {
  voltage
  geyser
  custom
}

type WalletState {
  """
  The status field is meant to be displayed in the the public view of a project to provide insight to the user
  that wants to contribute to the project.
  """
  status: WalletStatus!

  """
  The status code is a more descriptive field about the wallet status. It is meant to be displayed to the 
  project creator to help them understand what is wrong with their wallet connection. The field can only be queried
  by the project creator.
  """
  statusCode: WalletStatusCode!
}

enum WalletStatus {
  OK
  INACTIVE
  UNSTABLE
}

enum WalletStatusCode {
  OK
  UNREACHABLE
  NOT_FOUND
  WALLET_LOCKED
  NO_ROUTE
  UNKNOWN
}

enum WalletResourceType {
  project
  user
}

input ActivityCreatedSubscriptionInput {
  where: ActivityCreatedSubscriptionWhereInput
}

input ActivityCreatedSubscriptionWhereInput {
  resourceType: ActivityResourceType
  projectIds: [BigInt!]
  tagIds: [Int!]
  region: String
  countryCode: String
  feed: ActivityFeedName
  userIds: [BigInt!]
}

input GetActivitiesInput {
  where: GetActivityWhereInput
  pagination: GetActivityPaginationInput
}

input GetActivityWhereInput {
  projectIds: [BigInt!]
  tagIds: [Int!]
  region: String
  countryCode: String
  resourceType: ActivityResourceType
  userIds: [BigInt!]
  feed: ActivityFeedName
  createdAt: DateRangeInput
}

input ActivitiesCountGroupedByProjectInput {
  feed: ActivityFeedName!
  createdAt: DateRangeInput!
}

input GetActivityOrderByInput {
  createdAt: Date
}

input GetActivityPaginationInput {
  cursor: CursorInputString
  take: Int
}

input CursorInputString {
  id: String!
}

type Activity {
  id: String!
  project: Project!
  createdAt: Date!
  activityType: String!
  resource: ActivityResource!
}

type ActivitiesGetResponse {
  activities: [Activity!]!
  pagination: CursorPaginationResponse
}

type ProjectActivitiesCount {
  project: Project!
  count: Int!
}

enum ActivityResourceType {
  POST
  CONTRIBUTION
  PROJECT
  PROJECT_REWARD
  PROJECT_GOAL
}

union ActivityResource = Entry | Post | Contribution | Project | ProjectReward | ProjectGoal

enum ActivityFeedName {
  MY_PROJECTS
  FOLLOWED_PROJECTS
  GLOBAL_PROJECTS
}

type Tag {
  id: Int!
  label: String!
}

type TagsGetResult {
  id: Int!
  label: String!
  count: Int!
}

type TagsMostFundedGetResult {
  id: Int!
  label: String!
}

input TagCreateInput {
  label: String!
}

input GrantApplyInput {
  grantId: BigInt!
  projectId: BigInt!
}

input GrantGetInput {
  where: GrantGetWhereInput!
}

input GrantGetWhereInput {
  id: BigInt!
}

input GrantApplicantsGetWhereInput {
  status: GrantApplicantStatusFilter
}

input GrantApplicantsGetInput {
  where: GrantApplicantsGetWhereInput!
  pagination: PaginationInput
  orderBy: [GrantApplicantsGetOrderByInput!]
}

input GrantApplicantsGetOrderByInput {
  field: GrantApplicantsOrderByField!
  direction: OrderByDirection!
}

enum GrantApplicantsOrderByField {
  voteCount
}

union Grant = BoardVoteGrant | CommunityVoteGrant

type BoardVoteGrant {
  id: BigInt!
  title: String!
  name: String!
  image: String
  shortDescription: String!
  description: String
  balance: Int!
  status: GrantStatusEnum!
  statuses: [GrantStatus!]!
  applicants(input: GrantApplicantsGetInput): [GrantApplicant!]!
  sponsors: [Sponsor!]!
  boardMembers: [GrantBoardMember!]!
  type: GrantType!
}

type CommunityVoteGrant {
  id: BigInt!
  title: String!
  name: String!
  image: String
  shortDescription: String!
  description: String
  balance: Int!
  status: GrantStatusEnum!
  statuses: [GrantStatus!]!
  applicants(input: GrantApplicantsGetInput): [GrantApplicant!]!
  sponsors: [Sponsor!]!
  votes: CompetitionVoteGrantVoteSummary!
  votingSystem: VotingSystem!
  distributionSystem: DistributionSystem!
  type: GrantType!
}

type GrantGuardiansFunding {
  contributedTotal: BigInt!
  contributorsCount: BigInt!
}

type GrantStatistics {
  """Statistic about the grants"""
  grants: GrantStatisticsGrant

  """Statistic about the grant applicants"""
  applicants: GrantStatisticsApplicant
  grantGuardiansFunding: GrantGuardiansFunding!
}

type GrantStatisticsGrant {
  """Total amount granted to projects (in sats)"""
  amountGranted: Int!

  """Total amount sent to grants (in sats)"""
  amountFunded: Int!

  """Total rounds of grants"""
  count: Int!
}

type GrantStatisticsApplicant {
  """Count of applicants that have been funded"""
  countFunded: Int!
}

type GrantApplicant {
  id: BigInt!
  grant: Grant!
  project: Project!
  status: GrantApplicantStatus!
  contributorsCount: Int!
  voteCount: Int!
  contributors(input: GrantApplicantContributorInput): [GrantApplicantContributor!]!
  funding: GrantApplicantFunding!
}

input GrantApplicantContributorInput {
  pagination: PaginationInput
  where: GrantApplicantContributorWhereInput
}

input GrantApplicantContributorWhereInput {
  userId: BigInt!
}

type GrantApplicantFunding {
  """
  The amount of funding the grant applicant has received from the community.
  """
  communityFunding: Int!

  """The amount of grant funding the applicant is elligible for."""
  grantAmount: Int!

  """
  The amount of funding that the Grant applicant has been confirmed to receive. Can only be confirmed after the 
  grant has been closed.
  """
  grantAmountDistributed: Int!
}

type GrantApplicantContributor {
  user: User
  amount: Int!
  timesContributed: Int!
  voteCount: Int!
}

type GrantBoardMember {
  user: User!
}

type GrantStatus {
  status: GrantStatusEnum!
  startAt: Date!
  endAt: Date
}

enum GrantStatusEnum {
  APPLICATIONS_OPEN
  FUNDING_OPEN
  CLOSED
}

enum GrantApplicantStatus {
  ACCEPTED
  REJECTED
  PENDING
  CANCELED
  FUNDED
}

enum GrantApplicantStatusFilter {
  FUNDED
  ACCEPTED
}

enum GrantType {
  COMMUNITY_VOTE
  BOARD_VOTE
}

type CompetitionVoteGrantVoteSummary {
  voteCount: Int!
  voterCount: Int!
}

enum VotingSystem {
  ONE_TO_ONE
  STEP_LOG_10
}

enum DistributionSystem {
  NONE
  PROPORTIONAL
  WINNER_TAKE_ALL
}

type Sponsor {
  id: BigInt!
  name: String!
  url: String
  image: String
  user: User
  status: SponsorStatus!
  createdAt: Date!
}

enum SponsorStatus {
  PENDING
  ACCEPTED
  REJECTED
  CONFIRMED
  CANCELED
}

input BadgesGetInput {
  where: BadgesGetWhereInput
}

input BadgesGetWhereInput {
  userId: BigInt
  contributionId: BigInt
}

input BadgeClaimInput {
  userBadgeId: BigInt!
}

type UserBadge {
  id: BigInt!
  userId: BigInt!
  status: UserBadgeStatus
  badgeAwardEventId: String
  contributionId: BigInt
  createdAt: Date!
  updatedAt: Date!
  badge: Badge!
}

type Badge {
  id: String!
  uniqueName: String!
  name: String!
  description: String!
  image: String!
  createdAt: Date!
  thumb: String!
}

enum UserBadgeStatus {
  PENDING
  ACCEPTED
}

input SendOtpByEmailInput {
  email: String
  action: MFAAction!
}

type OTPResponse {
  """
  Encrypted token containing the OTP 2FA details, such as the action to be authorised and the factor used (eg: email).
  """
  otpVerificationToken: String!

  """
  Expiration time of the OTP. Can be used to display a countdown to the user.
  """
  expiresAt: Date!
}

enum MFAAction {
  USER_EMAIL_VERIFICATION
  USER_EMAIL_UPDATE
  PROJECT_WALLET_UPDATE
  LOGIN
}

type Order {
  id: BigInt!
  createdAt: Date!
  updatedAt: Date!
  confirmedAt: Date
  deliveredAt: Date
  shippedAt: Date
  status: String!
  totalInSats: Int!
  items: [OrderItem!]!
  user: User
  contribution: Contribution!
  referenceCode: String!
  project: Project!
}

type OrderItem {
  quantity: Int!
  unitPriceInSats: Int!
  item: ProjectReward!
}

type OrdersGetResponse {
  orders: [Order!]!
  pagination: CursorPaginationResponse
}

input GuardianUsersGetInput {
  where: GuardianUsersGetWhereInput
}

input GuardianUsersGetWhereInput {
  guardianType: GuardianType!
}

type GuardianUsersGetResponse {
  guardianUsers: [GuardianResult!]!
}

type GuardianResult {
  soldCount: Int!
  users: [GuardianUser!]!
  guardianType: GuardianType!
}

type GuardianUser {
  userId: BigInt!
  heroId: String!
  username: String!
  imageUrl: String
  guardianType: String!
}

input UniqueOrderInput {
  id: BigInt
}

input OrdersGetInput {
  where: OrdersGetWhereInput!
  orderBy: [OrdersGetOrderByInput!]
  pagination: PaginationInput
}

input OrdersGetOrderByInput {
  field: OrdersGetOrderByField!
  direction: OrderByDirection!
}

input OrdersGetWhereInput {
  projectId: BigInt
  status: OrdersGetStatus
  userId: BigInt
}

input OrderStatusUpdateInput {
  orderId: BigInt
  status: UpdatableOrderStatus
}

enum OrdersGetStatus {
  CONFIRMED
  SHIPPED
  DELIVERED
  AWAITING_PAYMENT
}

enum UpdatableOrderStatus {
  CONFIRMED
  SHIPPED
  DELIVERED
}

enum OrdersGetOrderByField {
  confirmedAt
  deliveredAt
  shippedAt
}

type ProfileNotificationSettings {
  userSettings: UserNotificationSettings!
  creatorSettings: [CreatorNotificationSettings!]!
}

type UserNotificationSettings {
  userId: BigInt!
  notificationSettings: [NotificationSettings!]!
}

type CreatorNotificationSettings {
  userId: BigInt!
  project: CreatorNotificationSettingsProject!
  notificationSettings: [NotificationSettings!]!
}

type CreatorNotificationSettingsProject {
  id: BigInt!
  title: String!
  image: String
}

type NotificationSettings {
  notificationType: String!
  isEnabled: Boolean!
  channel: NotificationChannel
  configurations: [NotificationConfiguration!]!
}

type NotificationConfiguration {
  id: BigInt!
  name: String!
  description: String
  value: String!
  type: SettingValueType
  options: [String!]!
}

enum SettingValueType {
  BOOLEAN
  STRING
  INTEGER
  ENUM
}

enum NotificationChannel {
  EMAIL
}

input UserVerificationTokenGenerateInput {
  verificationLevel: UserVerificationLevelInput!
}

enum UserVerificationLevelInput {
  LEVEL_2
  LEVEL_3
}

enum UserVerificationLevel {
  LEVEL_0
  LEVEL_1
  LEVEL_2
  LEVEL_3
}

type UserVerificationTokenGenerateResponse {
  verificationLevel: UserVerificationLevel!
  token: String!
}

input PaymentInvoiceSanctionCheckStatusGetInput {
  invoiceId: String!
}

type PaymentInvoiceSanctionCheckStatusResponse {
  status: PaymentInvoiceSanctionCheckStatus!
}

enum PaymentInvoiceSanctionCheckStatus {
  PENDING
  PASSED
  FAILED
}

type UserComplianceDetails {
  verifiedDetails: UserVerifiedDetails!
  currentVerificationLevel: UserVerificationLevelStatus!
  verificationLevels: [UserVerificationLevelStatus!]!
  contributionLimits: UserContributionLimits!
}

type UserVerificationLevelStatus {
  level: UserVerificationLevel!
  status: UserVerificationStatus!
  verifiedAt: Date
}

enum UserVerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

type UserVerifiedDetails {
  email: VerificationResult
  phoneNumber: VerificationResult
  identity: VerificationResult
}

type VerificationResult {
  verified: Boolean
  verifiedAt: Date
}

type UserContributionLimits {
  monthly: UserContributionLimit!
}

type UserContributionLimit {
  limit: Float!
  remaining: Float!
  reached: Boolean!
  nextReset: Date!
}

input GenerateAffiliatePaymentRequestsInput {
  """The invoice ID of the Hodl invoice for the associated funding tx."""
  invoiceId: String!
}

input GenerateAmbassadorPayoutRequestsInput {
  """The invoice ID of the Hodl invoice for the associated funding tx."""
  invoiceId: String!
}

type AmbassadorPayoutConfirmResponse {
  success: Boolean!
  message: String
}

type GenerateAmbassadorPayoutRequestResponse {
  ambassadorPayoutId: BigInt!
  paymentRequest: String!
}

input GetProjectOrdersStatsInput {
  where: GetProjectOrdersStatsWhereInput!
}

input GetProjectOrdersStatsWhereInput {
  projectId: BigInt!
}

type OrdersStatsBase {
  projectRewards: ProjectRewardsStats!
  projectRewardsGroupedByProjectRewardId: [ProjectRewardsGroupedByRewardIdStats!]!
}

type ProjectRewardsStats {
  count: Int!
}

type ProjectRewardsGroupedByRewardIdStats {
  projectReward: ProjectRewardsGroupedByRewardIdStatsProjectReward!
  count: Int!
}

type ProjectRewardTrendingWeeklyGetRow {
  projectReward: ProjectReward!
  count: Int!
}

type ProjectRewardTrendingMonthlyGetRow {
  projectReward: ProjectReward!
  count: Int!
}

type ProjectRewardsGroupedByRewardIdStatsProjectReward {
  id: BigInt!
  uuid: String!
  name: String!
  sold: Int!
  maxClaimable: Int
  image: String
  images: String
}

type UserSubscription {
  id: BigInt!
  projectSubscriptionPlan: ProjectSubscriptionPlan!
  status: UserSubscriptionStatus!
  startDate: Date!
  nextBillingDate: Date!
  canceledAt: Date
  createdAt: Date!
  updatedAt: Date!
}

type ProjectSubscriptionPlan {
  id: BigInt!
  projectId: BigInt!
  name: String!
  description: String
  cost: Int!
  currency: SubscriptionCurrencyType!
  interval: UserSubscriptionInterval!
  createdAt: Date!
  updatedAt: Date!
}

enum UserSubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELED
}

enum UserSubscriptionInterval {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

enum SubscriptionCurrencyType {
  USDCENT
}

input CreateUserSubscriptionInput {
  userId: BigInt!
  projectSubscriptionPlanId: BigInt!
}

input UpdateUserSubscriptionInput {
  id: BigInt!
  status: UserSubscriptionStatus
}

input CreateProjectSubscriptionPlanInput {
  projectId: BigInt!
  name: String!
  description: String
  amount: Int!
  currency: SubscriptionCurrencyType!
  intervalType: UserSubscriptionInterval!
}

input UpdateProjectSubscriptionPlanInput {
  id: BigInt!
  name: String
  description: String
  amount: Int
  currency: SubscriptionCurrencyType
  intervalType: UserSubscriptionInterval
  isHidden: Boolean
}

input ProjectSubscriptionPlansInput {
  where: ProjectSubscriptionPlansWhereInput!
}

input ProjectSubscriptionPlansWhereInput {
  projectId: BigInt!
}

input UserSubscriptionsInput {
  where: UserSubscriptionsWhereInput!
}

input UserSubscriptionsWhereInput {
  userId: BigInt!
}

type PaymentMethods {
  fiat: FiatPaymentMethods!
  bitcoin: BitcoinPaymentMethods!
}

type FiatPaymentMethods {
  enabled: Boolean!
  banxa: Boolean!
  stripe: Boolean!
}

type BitcoinPaymentMethods {
  lightning: LightningPaymentMethods!
  onChain: OnChainPaymentMethods!
}

type LightningPaymentMethods {
  bolt11: Boolean!
}

type OnChainPaymentMethods {
  boltzSwap: Boolean!
  native: Boolean!
}
